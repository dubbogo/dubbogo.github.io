<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="dubbo-go-code-notes-2" />
	<meta name="description" content="&gt;" />
	<!-- 网页标签标题 -->
	<title>&#34;dubbo-go源码笔记（二）客户端调用过程&#34;</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="https://dubbo.apache.org">首页</a></li><li class="menu-item menu-item-normal"><a href="https://dubbo.apache.org/zh/docs3-v2/golang-sdk/">文档</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="https://dubbo.apache.org/zh/blog/golang/">博客</a></li><li class="menu-item menu-item-normal"><a href="https://dubbo.apache.org/zh/blog/contact/">社区</a></li><li class="menu-item menu-item-normal"><a href="https://dubbo.apache.org/zh/release/">下载</a></li><li class="menu-item menu-item-normal"><a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/">Java</a></li></ul></div></div></header><section class="blog-content markdown-body"><h2>前言</h2>
<p>有了上一篇文章[《dubbo-go 源码笔记（一）Server服务暴露过程详解》]({{&lt;ref &quot;/blog/news/dubbo-go-codewalk-1.md&quot; &gt;}} &quot;&quot;) 的铺垫，可以大致上类比客户端服务类似于服务端启动过程。其中最大的区别是服务端通过zk注册服务，发布自己的ivkURL并订阅事件开启监听；而服务端应该是通过zk注册组件，<strong>拿到需要调用的serviceURL</strong>，<strong>更新invoker</strong>并<strong>重写用户的RPCService</strong>，从而实现对远程过程调用细节的封装。</p>
<h2>1. 配置文件和客户端源码</h2>
<h4>1.1 client配置文件</h4>
<p>helloworld提供的demo：profiles/client.yaml</p>
<pre><code class="language-yaml"><span class="hljs-attr">registries :</span>
  <span class="hljs-attr">"demoZk":</span>
    <span class="hljs-attr">protocol:</span> <span class="hljs-string">"zookeeper"</span>
    <span class="hljs-attr">timeout :</span> <span class="hljs-string">"3s"</span>
    <span class="hljs-attr">address:</span> <span class="hljs-string">"127.0.0.1:2181"</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">""</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">""</span>
<span class="hljs-attr">references:</span>
  <span class="hljs-attr">"UserProvider":</span>
    <span class="hljs-comment"># 可以指定多个registry，使用逗号隔开;不指定默认向所有注册中心注册</span>
    <span class="hljs-attr">registry:</span> <span class="hljs-string">"demoZk"</span>
    <span class="hljs-attr">protocol :</span> <span class="hljs-string">"dubbo"</span>
    <span class="hljs-attr">interface :</span> <span class="hljs-string">"com.ikurento.user.UserProvider"</span>
    <span class="hljs-attr">cluster:</span> <span class="hljs-string">"failover"</span>
    <span class="hljs-attr">methods :</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"GetUser"</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
</code></pre>
<p>可看到配置文件与之前讨论过的server端非常类似，其refrences部分字段就是对当前服务要主调的服务的配置，其中详细说明了调用协议、注册协议、接口id、调用方法、集群策略等，这些配置都会在之后与注册组件交互，重写ivk、调用的过程中使用到。</p>
<h4>1.2 客户端使用框架源码</h4>
<p>user.go</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {
    config.SetConsumerService(userProvider)
    hessian.RegisterPOJO(&amp;User{})
}
</code></pre>
<p>main.go</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    hessian.RegisterPOJO(&amp;User{})
    config.Load()
    time.Sleep(<span class="hljs-number">3e9</span>)
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"\n\n\nstart to test dubbo"</span>)
    user := &amp;User{}
    err := userProvider.GetUser(context.TODO(), []<span class="hljs-keyword">interface</span>{}{<span class="hljs-string">"A001"</span>}, user)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
      <span class="hljs-built_in">panic</span>(err)
    }
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"response result: %v\n"</span>, user)
    initSignal()
}
</code></pre>
<p>官网提供的helloworld demo的源码。可看到与服务端类似，在user.go内注册了rpc-service，以及需要rpc传输的结构体user。</p>
<p>在main函数中，同样调用了config.Load()函数，之后就可以直接通过实现好的rpc-service：userProvider 直接调用对应的功能函数，即可实现rpc调用。</p>
<p>可以猜到，从hessian注册结构、SetConsumerService，到调用函数.GetUser()期间，用户定义的rpc-service也就是userProvider对应的函数被重写，重写后的GetUser函数已经包含了实现了远程调用逻辑的invoker。</p>
<p>接下来，就要通过阅读源码，看看dubbo-go是如何做到的。</p>
<h2>2. 实现远程过程调用</h2>
<h4>2.1 加载配置文件</h4>
<p>config/config_loader.go :Load()</p>
<pre><code class="language-go"><span class="hljs-comment">// Load Dubbo Init</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Load</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// init router</span>
    initRouter()
    <span class="hljs-comment">// init the global event dispatcher</span>
    extension.SetAndInitGlobalDispatcher(GetBaseConfig().EventDispatcherType)
    <span class="hljs-comment">// start the metadata report if config set</span>
    <span class="hljs-keyword">if</span> err := startMetadataReport(GetApplicationConfig().MetadataType, GetBaseConfig().MetadataReportConfig); err != <span class="hljs-literal">nil</span> {
      logger.Errorf(<span class="hljs-string">"Provider starts metadata report error, and the error is {%#v}"</span>, err)
  <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// reference config</span>
    loadConsumerConfig()
</code></pre>
<p>在main函数中调用的config.Load()函数，进而调用了loadConsumerConfig，类似于之前讲到的server端配置读入函数。</p>
<p>在loadConsumerConfig函数中，进行了三步操作：</p>
<p><img src="/imgs/blog/dubbo-go/code2/p1.png" alt=""></p>
<ol>
<li>检查配置文件并将配置写入内存</li>
<li><strong>在for循环内部</strong>，依次引用（refer）并且实例化（implement）每个被调reference。</li>
<li>等待三秒钟所有invoker就绪</li>
</ol>
<p>其中重要的就是for循环里面的引用和实例化，两步操作，会在接下来展开讨论。</p>
<p>至此，配置已经被写入了框架。</p>
<h4>2.2 获取远程Service URL，实现可供调用的invoker</h4>
<p>上述的ref.Refer完成的就是这部分的操作。</p>
<p>图（一）</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p2.png" alt=""></p>
<h5>2.2.1 构造注册url</h5>
<p>和server端类似，存在注册url和服务url，dubbo习惯将服务url作为注册url的sub。</p>
<p>config/reference_config.go: Refer()</p>
<pre><code class="language-go">/ Refer ...
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ReferenceConfig)</span> <span class="hljs-title">Refer</span><span class="hljs-params">(_ <span class="hljs-keyword">interface</span>{})</span></span> {
    <span class="hljs-comment">//（一）配置url参数(serviceUrl)，将会作为sub</span>
    cfgURL := common.NewURLWithOptions(
  common.WithPath(c.id),
  common.WithProtocol(c.Protocol),
  common.WithParams(c.getUrlMap()),
  common.WithParamsValue(constant.BEAN_NAME_KEY, c.id),
    )
    ...
    <span class="hljs-comment">// （二）注册地址可以通过url格式给定，也可以通过配置格式给定</span>
    <span class="hljs-comment">// 这一步的意义就是配置-&gt;提取信息生成URL</span>
    <span class="hljs-keyword">if</span> c.Url != <span class="hljs-string">""</span> {<span class="hljs-comment">// 用户给定url信息，可以是点对点的地址，也可以是注册中心的地址</span>
  <span class="hljs-comment">// 1. user specified URL, could be peer-to-peer address, or register center's address.</span>
  urlStrings := gxstrings.RegSplit(c.Url, <span class="hljs-string">"\\s*[;]+\\s*"</span>)
  <span class="hljs-keyword">for</span> _, urlStr := <span class="hljs-keyword">range</span> urlStrings {
    serviceUrl, err := common.NewURL(urlStr)
    ...
  }
    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// 配置读入注册中心的信息</span>
  <span class="hljs-comment">//  assemble SubURL from register center's configuration mode</span>
  <span class="hljs-comment">// 这是注册url，protocol = registry,包含了zk的用户名、密码、ip等等</span>
  c.urls = loadRegistries(c.Registry, consumerConfig.Registries, common.CONSUMER)
  ...
  <span class="hljs-comment">// set url to regUrls</span>
  <span class="hljs-keyword">for</span> _, regUrl := <span class="hljs-keyword">range</span> c.urls {
    regUrl.SubURL = cfgURL<span class="hljs-comment">// regUrl的subURl存当前配置url</span>
  }
    }
    <span class="hljs-comment">//至此，无论通过什么形式，已经拿到了全部的regURL</span>
    <span class="hljs-comment">// （三）获取registryProtocol实例，调用其Refer方法，传入新构建好的regURL</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.urls) == <span class="hljs-number">1</span> {
  <span class="hljs-comment">// 这一步访问到registry/protocol/protocol.go registryProtocol.Refer</span>
  <span class="hljs-comment">// 这里是registry</span>
  c.invoker = extension.GetProtocol(c.urls[<span class="hljs-number">0</span>].Protocol).Refer(*c.urls[<span class="hljs-number">0</span>])
    } <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 如果有多个注册中心，即有多个invoker,则采取集群策略</span>
  invokers := <span class="hljs-built_in">make</span>([]protocol.Invoker, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(c.urls))
  ...
    }
</code></pre>
<p>这个函数中，已经处理完从Register配置到RegisterURL的转换,即图（一）中部分：</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p3.png" alt=""></p>
<p>接下来，已经拿到的url将被传递给RegistryProtocol，进一步refer。</p>
<h5>2.2.2 registryProtocol获取到zkRegistry实例，进一步Refer</h5>
<p>registry/protocol/protocol.go: Refer</p>
<pre><code class="language-go"><span class="hljs-comment">// Refer provider service from registry center</span>
<span class="hljs-comment">// 拿到的是配置文件registries的url，他能够生成一个invoker = 指向目的addr，以供客户端直接调用。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proto *registryProtocol)</span> <span class="hljs-title">Refer</span><span class="hljs-params">(url common.URL)</span> <span class="hljs-title">protocol</span>.<span class="hljs-title">Invoker</span></span> {
    <span class="hljs-keyword">var</span> registryUrl = url
    <span class="hljs-comment">// 这里拿到的是referenceConfig，serviceUrl里面包含了Reference的所有信息，包含interfaceName、method等等</span>
    <span class="hljs-keyword">var</span> serviceUrl = registryUrl.SubURL
    <span class="hljs-keyword">if</span> registryUrl.Protocol == constant.REGISTRY_PROTOCOL {<span class="hljs-comment">// registryUrl.Proto = "registry"</span>
  protocol := registryUrl.GetParam(constant.REGISTRY_KEY, <span class="hljs-string">""</span>)
  registryUrl.Protocol = protocol<span class="hljs-comment">//替换成了具体的值，比如"zookeeper"</span>
    }
    <span class="hljs-comment">// 接口对象</span>
    <span class="hljs-keyword">var</span> reg registry.Registry
    <span class="hljs-comment">// （一）实例化接口对象，缓存策略</span>
    <span class="hljs-keyword">if</span> regI, loaded := proto.registries.Load(registryUrl.Key()); !loaded {
  <span class="hljs-comment">// 缓存中不存在当前registry，新建一个reg</span>
  reg = getRegistry(&amp;registryUrl)
  <span class="hljs-comment">// 缓存起来</span>
  proto.registries.Store(registryUrl.Key(), reg)
    } <span class="hljs-keyword">else</span> {
  reg = regI.(registry.Registry)
    }
    <span class="hljs-comment">// 到这里，获取到了reg实例 zookeeper的registry</span>
    <span class="hljs-comment">//（二）根据Register的实例zkRegistry和传入的regURL新建一个directory</span>
    <span class="hljs-comment">// 这一步存在复杂的异步逻辑，从注册中心拿到了目的service的真实addr，获取了invoker并放入directory，</span>
    <span class="hljs-comment">// 这一步将在下面详细给出步骤</span>
    <span class="hljs-comment">// new registry directory for store service url from registry</span>
    directory, err := extension.GetDefaultRegistryDirectory(&amp;registryUrl, reg)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
  logger.Errorf(<span class="hljs-string">"consumer service %v  create registry directory  error, error message is %s, and will return nil invoker!"</span>,
    serviceUrl.String(), err.Error())
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    <span class="hljs-comment">// （三）DoRegister 在zk上注册当前client service</span>
    err = reg.Register(*serviceUrl)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
  logger.Errorf(<span class="hljs-string">"consumer service %v register registry %v error, error message is %s"</span>,
    serviceUrl.String(), registryUrl.String(), err.Error())
    }
    <span class="hljs-comment">// （四）new cluster invoker，将directory写入集群，获得具有集群策略的invoker</span>
    cluster := extension.GetCluster(serviceUrl.GetParam(constant.CLUSTER_KEY, constant.DEFAULT_CLUSTER))
    invoker := cluster.Join(directory)
    <span class="hljs-comment">// invoker保存</span>
    proto.invokers = <span class="hljs-built_in">append</span>(proto.invokers, invoker)
    <span class="hljs-keyword">return</span> invoker
}
</code></pre>
<p>可详细阅读上述注释，这个函数完成了从url到invoker的全部过程</p>
<p>（一）首先获得Registry对象，默认是之前实例化的zkRegistry，和之前server获取Registry的处理很类似。
（二）通过构造一个新的directory，异步拿到之前在zk上注册的server端信息，生成invoker
（三）在zk上注册当前service
（四）集群策略，获得最终invoker</p>
<p>这一步完成了图（一）中所有余下的绝大多数操作，接下来就需要详细的查看directory的构造过程：</p>
<h5>2.2.3 构造directory（包含较复杂的异步操作）</h5>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p4.png" alt=""></p>
<p>图（二）</p>
<p>上述的 <code>extension.GetDefaultRegistryDirectory(&amp;registryUrl, reg)</code>函数，本质上调用了已经注册好的<code>NewRegistryDirectory</code>函数:</p>
<p>registry/directory/directory.go: NewRegistryDirectory()</p>
<pre><code class="language-go"><span class="hljs-comment">// NewRegistryDirectory will create a new RegistryDirectory</span>
<span class="hljs-comment">// 这个函数作为default注册在extension上面</span>
<span class="hljs-comment">// url为注册url，reg为zookeeper registry</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRegistryDirectory</span><span class="hljs-params">(url *common.URL, registry registry.Registry)</span> <span class="hljs-params">(cluster.Directory, error)</span></span> {
    <span class="hljs-keyword">if</span> url.SubURL == <span class="hljs-literal">nil</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perrors.Errorf(<span class="hljs-string">"url is invalid, suburl can not be nil"</span>)
    }
    dir := &amp;RegistryDirectory{
  BaseDirectory:    directory.NewBaseDirectory(url),
  cacheInvokers:    []protocol.Invoker{},
  cacheInvokersMap: &amp;sync.Map{},
  serviceType:      url.SubURL.Service(),
  registry:         registry,
    }
    dir.consumerConfigurationListener = newConsumerConfigurationListener(dir)
    <span class="hljs-keyword">go</span> dir.subscribe(url.SubURL)
    <span class="hljs-keyword">return</span> dir, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>首先构造了一个注册directory，开启携程调用其subscribe函数，传入serviceURL。</p>
<p>这个directory目前包含了对应的zkRegistry，以及传入的URL，他cacheInvokers的部分是空的。</p>
<p>进入dir.subscribe(url.SubURL)这个异步函数：</p>
<p>registry/directory/directory.go: subscribe()</p>
<pre><code class="language-go"><span class="hljs-comment">// subscribe from registry</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dir *RegistryDirectory)</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(url *common.URL)</span></span> {
    <span class="hljs-comment">// 增加两个监听，</span>
    dir.consumerConfigurationListener.addNotifyListener(dir)
    dir.referenceConfigurationListener = newReferenceConfigurationListener(dir, url)
    <span class="hljs-comment">// subscribe调用</span>
    dir.registry.Subscribe(url, dir)
}
</code></pre>
<p>重点来了，他调用了zkRegistry的Subscribe方法,与此同时将自己作为ConfigListener传入</p>
<blockquote>
<p>我认为这种传入listener的设计模式非常值得学习，而且很有java的味道。</p>
<p>针对等待zk返回订阅信息这样的异步操作，需要传入一个Listener，这个Listener需要实现Notify方法，进而在作为参数传入内部之后，可以被异步地调用Notify，将内部触发的异步事件“传递出来”，再进一步处理加工。</p>
<p>层层的Listener事件链，能将传入的原始serviceURL通过zkConn发送给zk服务，获取到服务端注册好的url对应的二进制信息。</p>
<p>而Notify回调链，则将这串byte[]一步一步解析、加工；以事件的形式向外传递，最终落到directory上的时候，已经是成型的newInvokers了。</p>
<p>具体细节不再以源码形式展示，可参照上图查阅源码。</p>
</blockquote>
<p>至此已经拿到了server端注册好的真实invoker。</p>
<p>完成了图（一）中的部分：</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p5.png" alt=""></p>
<h5>2.2.4 构造带有集群策略的clusterinvoker</h5>
<p>经过上述操作，已经拿到了server端Invokers，放入了directory的cacheinvokers数组里面缓存。</p>
<p>后续的操作对应本文2.2.2的第四步，由directory生成带有特性集群策略的invoker</p>
<pre><code class="language-go"><span class="hljs-comment">// （四）new cluster invoker，将directory写入集群，获得具有集群策略的invoker</span>
    cluster := extension.GetCluster(serviceUrl.GetParam(constant.CLUSTER_KEY, constant.DEFAULT_CLUSTER))
    invoker := cluster.Join(directory)
<span class="hljs-number">123</span>
</code></pre>
<p>Join函数的实现就是如下函数：</p>
<p>cluster/cluster_impl/failover_cluster_invokers.go: newFailoverClusterInvoker()</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newFailoverClusterInvoker</span><span class="hljs-params">(directory cluster.Directory)</span> <span class="hljs-title">protocol</span>.<span class="hljs-title">Invoker</span></span> {
    <span class="hljs-keyword">return</span> &amp;failoverClusterInvoker{
  baseClusterInvoker: newBaseClusterInvoker(directory),
    }
}
<span class="hljs-number">12345</span>
</code></pre>
<p>dubbo-go框架默认选择failover策略，既然返回了一个invoker，我们查看一下failoverClusterInvoker的Invoker方法，看他是如何将集群策略封装到Invoker函数内部的：</p>
<p>cluster/cluster_impl/failover_cluster_invokers.go: Invoker()</p>
<pre><code class="language-go"><span class="hljs-comment">// Invoker 函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(invoker *failoverClusterInvoker)</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(ctx context.Context, invocation protocol.Invocation)</span> <span class="hljs-title">protocol</span>.<span class="hljs-title">Result</span></span> {
    ...
    <span class="hljs-comment">//调用List方法拿到directory缓存的所有invokers</span>
    invokers := invoker.directory.List(invocation)
    <span class="hljs-keyword">if</span> err := invoker.checkInvokers(invokers, invocation); err != <span class="hljs-literal">nil</span> {<span class="hljs-comment">// 检查是否可以实现调用</span>
  <span class="hljs-keyword">return</span> &amp;protocol.RPCResult{Err: err}
    }
    <span class="hljs-comment">// 获取来自用户方向传入的</span>
    methodName := invocation.MethodName()
    retries := getRetries(invokers, methodName)
    loadBalance := getLoadBalance(invokers[<span class="hljs-number">0</span>], invocation)
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= retries; i++ {
  <span class="hljs-comment">// 重要！这里是集群策略的体现，失败后重试！</span>
  <span class="hljs-comment">//Reselect before retry to avoid a change of candidate `invokers`.</span>
  <span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span>
  <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {
    <span class="hljs-keyword">if</span> err := invoker.checkWhetherDestroyed(); err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> &amp;protocol.RPCResult{Err: err}
    }
    invokers = invoker.directory.List(invocation)
    <span class="hljs-keyword">if</span> err := invoker.checkInvokers(invokers, invocation); err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> &amp;protocol.RPCResult{Err: err}
    }
  }
  <span class="hljs-comment">// 这里是负载均衡策略的体现！选择特定ivk进行调用。</span>
  ivk := invoker.doSelect(loadBalance, invocation, invokers, invoked)
  <span class="hljs-keyword">if</span> ivk == <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">continue</span>
  }
  invoked = <span class="hljs-built_in">append</span>(invoked, ivk)
  <span class="hljs-comment">//DO INVOKE</span>
  result = ivk.Invoke(ctx, invocation)
  <span class="hljs-keyword">if</span> result.Error() != <span class="hljs-literal">nil</span> {
    providers = <span class="hljs-built_in">append</span>(providers, ivk.GetUrl().Key())
    <span class="hljs-keyword">continue</span>
  }
  <span class="hljs-keyword">return</span> result
    }
    ...
}
</code></pre>
<blockquote>
<p>看了很多Invoke函数的实现，所有类似的Invoker函数都包含两个方向，一个是用户方向的invcation，一个是函数方向的底层invokers。</p>
<p>而集群策略的invoke函数本身作为接线员，把invocation一步步解析，根据调用需求和集群策略，选择特定的invoker来执行</p>
<p>proxy函数也是这样，一个是用户方向的ins[] reflect.Type, 一个是函数方向的invoker。</p>
<p>proxy函数负责将ins转换为invocation，调用对应invoker的invoker函数，实现连通。</p>
<p>而出于这样的设计，可以在一步步Invoker封装的过程中，每个Invoker只关心自己负责操作的部分，从而使整个调用栈解耦。</p>
<p>妙啊！！！</p>
</blockquote>
<p>至此，我们理解了failoverClusterInvoker 的Invoke函数实现，也正是和这个集群策略Invoker被返回，接受来自上方的调用。</p>
<p>已完成图（一）中的：</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p6.png" alt=""></p>
<h5>2.2.5 在zookeeper上注册当前client</h5>
<p>拿到invokers后，可以回到：</p>
<p>config/refrence_config.go: Refer()函数了。</p>
<pre><code class="language-go">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.urls) == <span class="hljs-number">1</span> {
  <span class="hljs-comment">// 这一步访问到registry/protocol/protocol.go registryProtocol.Refer</span>
  c.invoker = extension.GetProtocol(c.urls[<span class="hljs-number">0</span>].Protocol).Refer(*c.urls[<span class="hljs-number">0</span>])
  <span class="hljs-comment">// （一）拿到了真实的invokers</span>
    } <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 如果有多个注册中心，即有多个invoker,则采取集群策略</span>
  invokers := <span class="hljs-built_in">make</span>([]protocol.Invoker, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(c.urls))
  ...
  cluster := extension.GetCluster(hitClu)
  <span class="hljs-comment">// If 'zone-aware' policy select, the invoker wrap sequence would be:</span>
  <span class="hljs-comment">// ZoneAwareClusterInvoker(StaticDirectory) -&gt;</span>
  <span class="hljs-comment">// FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span>
  c.invoker = cluster.Join(directory.NewStaticDirectory(invokers))
    }
    <span class="hljs-comment">// （二）create proxy，为函数配置代理</span>
    <span class="hljs-keyword">if</span> c.Async {
  callback := GetCallback(c.id)
  c.pxy = extension.GetProxyFactory(consumerConfig.ProxyFactory).GetAsyncProxy(c.invoker, callback, cfgURL)
    } <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 这里c.invoker已经是目的addr了</span>
  c.pxy = extension.GetProxyFactory(consumerConfig.ProxyFactory).GetProxy(c.invoker, cfgURL)
    }
</code></pre>
<p>我们有了可以打通的invokers，但还不能直接调用，因为invoker的入参是invocation，而调用函数使用的是具体的参数列表。需要通过一层proxy来规范入参和出参。</p>
<p>接下来新建一个默认proxy，放置在c.proxy内，以供后续使用</p>
<p>至此，完成了图（一）中最后的操作</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p7.png" alt=""></p>
<h3>2.3 将调用逻辑以代理函数的形式写入rpc-service</h3>
<p>上面完成了config.Refer操作</p>
<p>回到config/config_loader.go: loadConsumerConfig()</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p8.png" alt=""></p>
<p>下一个重要的函数是Implement，他完的操作较为简单：旨在使用上面生成的c.proxy代理，链接用户自己定义的rpcService到clusterInvoker的信息传输。</p>
<p>函数较长，只选取了重要的部分:</p>
<p>common/proxy/proxy.go: Implement()</p>
<pre><code class="language-go"><span class="hljs-comment">// Implement</span>
<span class="hljs-comment">// proxy implement</span>
<span class="hljs-comment">// In consumer, RPCService like:</span>
<span class="hljs-comment">//      type XxxProvider struct {</span>
<span class="hljs-comment">//    Yyy func(ctx context.Context, args []interface{}, rsp *Zzz) error</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">// Implement 实现的过程，就是proxy根据函数名和返回值，通过调用invoker 构造出拥有远程调用逻辑的代理函数</span>
<span class="hljs-comment">// 将当前rpc所有可供调用的函数注册到proxy.rpc内</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Proxy)</span> <span class="hljs-title">Implement</span><span class="hljs-params">(v common.RPCService)</span></span> {
    <span class="hljs-comment">// makeDubboCallProxy 这是一个构造代理函数，这个函数的返回值是func(in []reflect.Value) []reflect.Value 这样一个函数</span>
    <span class="hljs-comment">// 这个被返回的函数是请求实现的载体，由他来发起调用获取结果</span>
    makeDubboCallProxy := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(methodName <span class="hljs-keyword">string</span>, outs []reflect.Type)</span> <span class="hljs-title">func</span><span class="hljs-params">(in []reflect.Value)</span> []<span class="hljs-title">reflect</span>.<span class="hljs-title">Value</span></span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(in []reflect.Value)</span> []<span class="hljs-title">reflect</span>.<span class="hljs-title">Value</span></span> {
    <span class="hljs-comment">// 根据methodName和outs的类型，构造这样一个函数，这个函数能将in 输入的value转换为输出的value</span>
    <span class="hljs-comment">// 这个函数具体的实现如下：</span>
    ...
    <span class="hljs-comment">// 目前拿到了 methodName、所有入参的interface和value，出参数reply</span>
    <span class="hljs-comment">// （一）根据这些生成一个 rpcinvocation</span>
    inv = invocation_impl.NewRPCInvocationWithOptions(
    invocation_impl.WithMethodName(methodName),
    invocation_impl.WithArguments(inIArr),
    invocation_impl.WithReply(reply.Interface()),
    invocation_impl.WithCallBack(p.callBack),
    invocation_impl.WithParameterValues(inVArr))
    <span class="hljs-keyword">for</span> k, value := <span class="hljs-keyword">range</span> p.attachments {
    inv.SetAttachments(k, value)
    }
    <span class="hljs-comment">// add user setAttachment</span>
    atm := invCtx.Value(constant.AttachmentKey) <span class="hljs-comment">// 如果传入的ctx里面有attachment，也要写入inv</span>
    <span class="hljs-keyword">if</span> m, ok := atm.(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>); ok {
    <span class="hljs-keyword">for</span> k, value := <span class="hljs-keyword">range</span> m {
        inv.SetAttachments(k, value)
    }
    }
    <span class="hljs-comment">// 至此构造inv完毕</span>
    <span class="hljs-comment">// (二）触发Invoker 之前已经将cluster_invoker放入proxy，使用Invoke方法，通过getty远程过程调用</span>
    result := p.invoke.Invoke(invCtx, inv)
    <span class="hljs-comment">// 如果有attachment，则加入</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result.Attachments()) &gt; <span class="hljs-number">0</span> {
    invCtx = context.WithValue(invCtx, constant.AttachmentKey, result.Attachments())
    }
    ...
  }
    }
    numField := valueOfElem.NumField()
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numField; i++ {
  t := typeOf.Field(i)
  methodName := t.Tag.Get(<span class="hljs-string">"dubbo"</span>)
  <span class="hljs-keyword">if</span> methodName == <span class="hljs-string">""</span> {
    methodName = t.Name
  }
  f := valueOfElem.Field(i)
  <span class="hljs-keyword">if</span> f.Kind() == reflect.Func &amp;&amp; f.IsValid() &amp;&amp; f.CanSet() { <span class="hljs-comment">// 针对于每个函数</span>
    outNum := t.Type.NumOut()
    <span class="hljs-comment">// 规定函数输出只能有1/2个</span>
    <span class="hljs-keyword">if</span> outNum != <span class="hljs-number">1</span> &amp;&amp; outNum != <span class="hljs-number">2</span> {
    logger.Warnf(<span class="hljs-string">"method %s of mtype %v has wrong number of in out parameters %d; needs exactly 1/2"</span>,
        t.Name, t.Type.String(), outNum)
    <span class="hljs-keyword">continue</span>
    }
    <span class="hljs-comment">// The latest return type of the method must be error.</span>
    <span class="hljs-comment">// 规定最后一个返回值一定是error</span>
    <span class="hljs-keyword">if</span> returnType := t.Type.Out(outNum - <span class="hljs-number">1</span>); returnType != typError {
    logger.Warnf(<span class="hljs-string">"the latest return type %s of method %q is not error"</span>, returnType, t.Name)
    <span class="hljs-keyword">continue</span>
    }
    <span class="hljs-comment">// 获取到所有的出参类型，放到数组里</span>
    <span class="hljs-keyword">var</span> funcOuts = <span class="hljs-built_in">make</span>([]reflect.Type, outNum)
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; outNum; i++ {
    funcOuts[i] = t.Type.Out(i)
    }
    <span class="hljs-comment">// do method proxy here:</span>
    <span class="hljs-comment">// （三）调用make函数，传入函数名和返回值，获得能调用远程的proxy，将这个proxy替换掉原来的函数位置</span>
    f.Set(reflect.MakeFunc(f.Type(), makeDubboCallProxy(methodName, funcOuts)))
    logger.Debugf(<span class="hljs-string">"set method [%s]"</span>, methodName)
  }
    }
    ...
}
</code></pre>
<p>正如之前所说，proxy的作用是将用户定义的函数参数列表，转化为抽象的invocation传入Invoker，进行调用。</p>
<p>其中已标明有三处较为重要的地方：</p>
<ol>
<li>在代理函数中实现由参数列表生成Invocation的逻辑</li>
<li>在代理函数实现调用Invoker的逻辑</li>
<li>将代理函数替换为原始rpc-service对应函数
至此，也就解决了一开始的问题：
client.go: main()</li>
</ol>
<pre><code class="language-go">    config.Load()
    user := &amp;User{}
    err := userProvider.GetUser(context.TODO(), []<span class="hljs-keyword">interface</span>{}{<span class="hljs-string">"A001"</span>}, user)
</code></pre>
<p>这里直接调用用户定义的rpcService的函数GetUser，这里实际调用的是经过重写入的函数代理，所以就能实现远程调用了。</p>
<h3>3. 从client到server的invoker嵌套链- 小结</h3>
<p>在阅读dubbo-go源码的过程中，我能发现一条清晰的invoker-proxy嵌套链，我希望通过图的形式来展现：</p>
<p><img src="img/blog/dubbo-go-code-notes-2.resource/p9.png" alt=""></p>
<blockquote>
<p>作者简介 李志信 (GitHubID LaurenceLiZhixin)，中山大学软件工程专业在校学生，擅长使用 Java/Go 语言，专注于云原生和微服务等技术方向。</p>
</blockquote>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/concept/what_is_dubbogo.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/dubbogo/dubbogo.github.io/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/dubbogo/dubbogo.github.io" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2020 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/blogDetail.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>